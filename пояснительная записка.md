### Почему я реализовал задание именно так и 

- Задание можно было реализовать по-разному, например, с помощью того же `input()` запрашивать информацию о пользователе, операции и т.д., но решение с помощью `argparse` мне показалось более практичным и интересным
- Для хранения данных был выбран формат JSON, т.к:

    Во-первых, он является текстовым, что обязательно по техническому заданию
  
    Во-вторых, JSON лучше работает с большим объемом данных
  
    В-третьих, если понадобиться в дальнейшем, можно будет прикруть API и создать веб-интерфейс программы
  
- Для реализации интерфейса через консоль был выбран модуль `argparse` и он является рекомендуемым к использованию модулем стандартной библиотеки `Python` для работы с аргументами командной строки
- Информация в справочнике храниться следующим образом:

```
{
  "contacts": [
    {
      "surname": "Иванов",
      "name": "Иван",
      "patronymic": "Иванович",
      "organization": "Effective Mobile",
      "personal phone number": "+79999999999",
      "work phone number": "+88888888888"
    },
    {
      "surname": "Иванов",
      "name": "Иван",
      "patronymic": "-",
      "organization": "Yandex",
      "personal phone number": "+79999999999",
      "work phone number": "+88888888888"
    },
    {
      "surname": "Иванов",
      "name": "Иван",
      "patronymic": "-",
      "organization": "Google",
      "personal phone number": "+79999999999",
      "work phone number": "+79999999999"
    }
  ]
}
```
- От себя добавил модуль `colorama`, что бы вывод в консоль был не такой скучный и обыкновенный, а более ориентированный на пользователя и приятный для глаза.
- Разбил проект программы на подпапки, что не засорять файл `main.py` повторяющимися кусками кода или не нагромаждать его огромными конструкциями. В общем, что бы `main.py` был более аккуратный
- Функция по поиску совпадений, лично мне кажется, реализована интересно. Мы передаём список с данными из парсера в функцию, после чего подгружаем `.json` файл и преобразуем значения словаря и списка во множество `set()`, после чего проверяем, если `len()` множества с пересечением значений словаря и списка (из которого мы предварительно удалили `None`) равно всем переданым значениям словаря (так же самое, исключая `None`), то мы добавляем контакт в список подходящих и после того, как прошлись по всем `JSON` файлу - возвращаем этот список с контактами. Это решение показалось мне самым элегантным и красивым, в отличие от кучи вложенных друг в друга `if ...`
